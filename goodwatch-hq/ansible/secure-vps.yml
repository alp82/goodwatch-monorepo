---
- name: Security Audit Playbook
  hosts: all
  become: yes
  gather_facts: yes

  vars:
    report_path: "./security_audit_report_{{ inventory_hostname }}.md"
    audit_results:
      os_check: {}
      dependencies: {}
      ufw: {}
      ssh: {}
      non_root_user: {}
      unattended_upgrades: {}
      fail2ban: {}

  tasks:
    # 1. Check Operating System
    - name: Check Operating System
      command: >
        {{
          'lsb_release -si | tr "[:upper:]" "[:lower:]"' if ansible_os_family == 'Debian' else
          'echo unsupported'
        }}
      register: os_check
      changed_when: false

    - name: Record OS Check Result
      set_fact:
        audit_results: >
          {{
            audit_results | combine({
              'os_check': {
                'status': 'PASS' if os_check.stdout in ['ubuntu', 'debian'] else 'FAIL',
                'message': 'Detected supported OS: ' + os_check.stdout if os_check.stdout in ['ubuntu', 'debian'] else 'Unsupported OS detected.'
              }
            })
          }}

    # 2. Check Required Dependencies
    - name: Define list of dependencies
      set_fact:
        dependencies_list:
          - curl
          - jq
          - systemctl
          - apt-get

    - name: Check Required Dependencies
      command: "command -v {{ item }}"
      register: dependency_check
      loop: "{{ dependencies_list }}"
      ignore_errors: yes

    - name: Collect missing dependencies
      set_fact:
        missing_dependencies: "{{ missing_dependencies | default([]) + [item.item] }}"
      when: item.rc != 0
      loop: "{{ dependency_check.results }}"

    - name: Record Dependencies Check Result
      set_fact:
        audit_results: >
          {{
            audit_results | combine({
              'dependencies': {
                'status': 'FAIL' if missing_dependencies | length > 0 else 'PASS',
                'message': 'Missing dependencies: ' + missing_dependencies | join(', ') if missing_dependencies | length > 0 else 'All required dependencies are installed.'
              }
            })
          }}

    # 3. UFW Security Check
    - name: Check UFW Installation
      apt:
        name: ufw
        state: present
      check_mode: yes
      register: ufw_installed
      changed_when: false

    - name: Record UFW Installation Result
      set_fact:
        audit_results: >
          {{
            audit_results | combine({
              'ufw': {
                'installation': {
                  'status': 'PASS' if ufw_installed is success else 'FAIL',
                  'message': 'UFW is installed.' if ufw_installed is success else 'UFW is not installed.'
                }
              }
            })
          }}

    - name: Check UFW Status
      command: ufw status
      register: ufw_status
      when: audit_results.ufw.installation.status == 'PASS'
      changed_when: false

    - name: Record UFW Active Status
      set_fact:
        audit_results: >
          {{
            audit_results | combine({
              'ufw': audit_results.ufw | combine({
                'active_status': {
                  'status': 'PASS' if 'Status: active' in ufw_status.stdout else 'FAIL',
                  'message': 'UFW is active.' if 'Status: active' in ufw_status.stdout else 'UFW is not active.'
                }
              })
            })
          }}
      when: ufw_status is defined

    - name: Check UFW Default Incoming Policy
      command: ufw status verbose
      register: ufw_policy
      when: audit_results.ufw.active_status.status == 'PASS'
      changed_when: false

    - name: Record UFW Default Incoming Policy
      set_fact:
        audit_results: >
          {{
            audit_results | combine({
              'ufw': audit_results.ufw | combine({
                'default_policy': {
                  'status': 'PASS' if 'Default: deny (incoming)' in ufw_policy.stdout else 'FAIL',
                  'message': 'Default incoming policy is set to deny.' if 'Default: deny (incoming)' in ufw_policy.stdout else 'Default incoming policy is not set to deny.'
                }
              })
            })
          }}
      when: ufw_policy is defined

    # 4. SSH Security Check
    - name: Check SSH Service Status
      service_facts:

    - name: Record SSH Service Status
      set_fact:
        audit_results: >
          {{
            audit_results | combine({
              'ssh': {
                'service_status': {
                  'status': 'PASS' if ansible_facts.services['ssh.service'].state == 'running' else 'PASS_DISABLED',
                  'message': 'SSH service is enabled.' if ansible_facts.services['ssh.service'].state == 'running' else 'SSH service is disabled.'
                }
              }
            })
          }}

    - name: Check SSH Key-based Authentication
      stat:
        path: "/home/{{ ansible_user }}/.ssh/authorized_keys"
      register: ssh_auth_keys
      when: audit_results.ssh.service_status.status == 'PASS'

    - name: Record SSH Key-based Authentication Result
      set_fact:
        audit_results: >
          {{
            audit_results | combine({
              'ssh': audit_results.ssh | combine({
                'key_auth': {
                  'status': 'PASS' if ssh_auth_keys.stat.exists else 'FAIL',
                  'message': 'Key-based authentication is set up.' if ssh_auth_keys.stat.exists else 'No authorized_keys found in home directory.'
                }
              })
            })
          }}
      when: ssh_auth_keys is defined

    # 5. Non-Root User Check
    - name: Check Non-Root Sudo Users
      shell: |
        grep -Po '^sudo:.*:\K.*$' /etc/group | tr ',' '\n' | grep -v '^root$'
      register: sudo_users
      changed_when: false

    - name: Check Admin Group Users
      shell: |
        grep -Po '^admin:.*:\K.*$' /etc/group | tr ',' '\n' | grep -v '^root$'
      register: admin_users
      changed_when: false

    - name: Combine Sudo and Admin Users
      set_fact:
        privileged_users: "{{ (sudo_users.stdout_lines + admin_users.stdout_lines) | unique | reject('equalto', '') | list }}"

    - name: Check Valid Shells for Sudo Users
      command: |
        getent passwd {{ item }} | cut -d: -f7
      register: user_shells
      loop: "{{ privileged_users }}"
      when: privileged_users | length > 0
      changed_when: false

    - name: Record Non-Root Sudo Users Result
      set_fact:
        audit_results: >
          {{
            audit_results | combine({
              'non_root_user': {
                'sudo_access': {
                  'status': 'PASS' if user_shells.results | selectattr('stdout', 'match', '^(?!/usr/sbin/nologin$)(?!/bin/false$).+') | list | length > 0 else 'FAIL',
                  'message': 'Found valid non-root sudo users.' if user_shells.results | selectattr('stdout', 'match', '^(?!/usr/sbin/nologin$)(?!/bin/false$).+') | list | length > 0 else 'No non-root users with sudo privileges have valid shells.'
                }
              }
            })
          }}
      when: user_shells is defined

    # 6. Unattended Upgrades Check
    - name: Check Unattended Upgrades Installation
      apt:
        name: unattended-upgrades
        state: present
      check_mode: yes
      register: unattended_upgrades_installed
      changed_when: false

    - name: Record Unattended Upgrades Installation Result
      set_fact:
        audit_results: >
          {{
            audit_results | combine({
              'unattended_upgrades': {
                'installation': {
                  'status': 'PASS' if unattended_upgrades_installed is success else 'FAIL',
                  'message': 'unattended-upgrades package is installed.' if unattended_upgrades_installed is success else 'unattended-upgrades package is not installed.'
                }
              }
            })
          }}

    # 7. Fail2ban Check
    - name: Check Fail2ban Installation
      apt:
        name: fail2ban
        state: present
      check_mode: yes
      register: fail2ban_installed
      changed_when: false

    - name: Record Fail2ban Installation Result
      set_fact:
        audit_results: >
          {{
            audit_results | combine({
              'fail2ban': {
                'installation': {
                  'status': 'PASS' if fail2ban_installed is success else 'FAIL',
                  'message': 'fail2ban package is installed.' if fail2ban_installed is success else 'fail2ban package is not installed.'
                }
              }
            })
          }}

    # Generate Report
    - name: Generate Markdown Report
      template:
        src: security_audit_report.j2
        dest: "{{ report_path }}"
      vars:
        audit_results: "{{ audit_results }}"

    - name: Display Report Path
      debug:
        msg: "Security audit report generated at {{ report_path }}"