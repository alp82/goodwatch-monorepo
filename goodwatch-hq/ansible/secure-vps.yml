---
- name: Security Audit Playbook
  hosts: all
  become: yes
  gather_facts: no

  vars:
    report_path: "./security_audit_report_{{ inventory_hostname }}.md"
    audit_results:
      os_check: {}
      dependencies: {}
      ufw: {}
      ssh: {}
      non_root_user: {}
      unattended_upgrades: {}
      fail2ban: {}

  tasks:

    - name: Check Operating System
      shell: |
        if [ -f /etc/lsb-release ]; then
          echo "ubuntu"
        elif [ -f /etc/debian_version ]; then
          echo "debian"
        else
          echo "unsupported"
        fi
      register: os_check
      ignore_errors: yes

    - name: Record OS Check Result
      set_fact:
        audit_results: "{{ audit_results | combine({'os_check': {'status': os_status, 'message': os_message}}) }}"
      vars:
        os_status: "{{ 'PASS' if os_check.stdout in ['ubuntu', 'debian'] else 'FAIL' }}"
        os_message: "{{ 'Detected supported OS: ' + os_check.stdout if os_check.stdout in ['ubuntu', 'debian'] else 'Unsupported OS detected.' }}"
      when: os_check is defined

    - name: Define list of dependencies
      set_fact:
        dependencies_list:
          - curl
          - jq
          - systemctl
          - apt-get

    - name: Check Required Dependencies
      command: "command -v {{ item }}"
      register: dependency_check
      ignore_errors: yes
      loop: "{{ dependencies_list }}"

    - name: Collect missing dependencies
      set_fact:
        missing_dependencies: "{{ missing_dependencies | default([]) + [item.item] }}"
      when: item.rc != 0
      loop: "{{ dependency_check.results }}"

    - name: Record Dependencies Check Result
      set_fact:
        audit_results: "{{ audit_results | combine({'dependencies': {'status': dep_status, 'message': dep_message}}) }}"
      vars:
        dep_status: "{{ 'FAIL' if missing_dependencies | length > 0 else 'PASS' }}"
        dep_message: "{{ 'Missing dependencies: ' + missing_dependencies | join(', ') if missing_dependencies | length > 0 else 'All required dependencies are installed.' }}"
      when: dependency_check is defined

    - name: Check UFW Installation
      apt:
        name: ufw
        state: present
      check_mode: yes
      register: ufw_installed
      ignore_errors: yes

    - name: Record UFW Installation Result
      set_fact:
        audit_results: "{{ audit_results | combine({'ufw': audit_ufw}) }}"
      vars:
        audit_ufw:
          installation:
            status: "{{ 'PASS' if ufw_installed.changed == False else 'FAIL' }}"
            message: "{{ 'UFW is installed.' if ufw_installed.changed == False else 'UFW is not installed.' }}"
      when: ufw_installed is defined

    - name: Check UFW Status
      shell: ufw status | grep "Status: active"
      register: ufw_active
      when: audit_results.ufw.installation.status == 'PASS'
      ignore_errors: yes

    - name: Record UFW Active Status
      set_fact:
        audit_results: "{{ audit_results | combine({'ufw': audit_ufw_updated}) }}"
      vars:
        ufw_ufw_updated: "{{ audit_results.ufw | combine({'active_status': {'status': ufw_status, 'message': ufw_message}}) }}"
        ufw_status: "{{ 'PASS' if ufw_active.rc == 0 else 'FAIL' }}"
        ufw_message: "{{ 'UFW is active.' if ufw_active.rc == 0 else 'UFW is not active.' }}"
      when: ufw_active is defined and audit_results.ufw is defined

    - name: Check UFW Default Incoming Policy
      shell: |
        ufw status verbose | grep "Default: " | awk '{print $2}'
      register: ufw_default_incoming
      when: audit_results.ufw.active_status.status == 'PASS'
      ignore_errors: yes

    - name: Record UFW Default Incoming Policy
      set_fact:
        audit_results: "{{ audit_results | combine({'ufw': audit_ufw_policy}) }}"
      vars:
        ufw_policy_status: "{{ 'PASS' if ufw_default_incoming.stdout == 'deny' else 'FAIL' }}"
        ufw_policy_message: "{{ 'Default incoming policy is set to deny.' if ufw_default_incoming.stdout == 'deny' else 'Default incoming policy is not set to deny.' }}"
        audit_ufw_policy: "{{ audit_results.ufw | combine({'default_policy': {'status': ufw_policy_status, 'message': ufw_policy_message}}) }}"
      when: ufw_default_incoming is defined and audit_results.ufw is defined

    - name: Check SSH Service Status
      shell: |
        systemctl is-active sshd || systemctl is-active ssh.service
      register: ssh_active
      ignore_errors: yes

    - name: Record SSH Service Status
      set_fact:
        audit_results: "{{ audit_results | combine({'ssh': ssh_service}) }}"
      vars:
        ssh_service:
          service_status:
            status: "{{ 'PASS' if ssh_active.rc == 0 else 'PASS_DISABLED' }}"
            message: "{{ 'SSH service is enabled.' if ssh_active.rc == 0 else 'SSH service is disabled.' }}"
      when: ssh_active is defined

    - name: Check SSH Key-based Authentication
      stat:
        path: "/home/{{ ansible_user }}/.ssh/authorized_keys"
      register: ssh_auth_keys
      when: audit_results.ssh.service_status.status == 'PASS'

    - name: Record SSH Key-based Authentication Result
      set_fact:
        audit_results: "{{ audit_results | combine({'ssh': ssh_ssh}) }}"
      vars:
        ssh_ssh:
          key_auth:
            status: "{{ 'PASS' if ssh_auth_keys.stat.exists else 'FAIL' }}"
            message: "{{ 'Key-based authentication is set up.' if ssh_auth_keys.stat.exists else 'No authorized_keys found in home directory.' }}"
      when: ssh_auth_keys is defined and audit_results.ssh is defined

    - name: Check SSH Configuration Settings
      shell: |
        sshd -T
      register: sshd_config
      when: audit_results.ssh.service_status.status == 'PASS'
      ignore_errors: yes

    - name: Parse SSH Configuration
      set_fact:
        ssh_config:
          PermitRootLogin: "{{ (sshd_config.stdout | regex_search('^permitrootlogin\\s+(\\S+)', '\\1', 'i')) | default('not set') | lower }}"
          KbdInteractiveAuthentication: "{{ (sshd_config.stdout | regex_search('^kbdinteractiveauthentication\\s+(\\S+)', '\\1', 'i')) | default('not set') | lower }}"
          PasswordAuthentication: "{{ (sshd_config.stdout | regex_search('^passwordauthentication\\s+(\\S+)', '\\1', 'i')) | default('not set') | lower }}"
          UsePAM: "{{ (sshd_config.stdout | regex_search('^usepam\\s+(\\S+)', '\\1', 'i')) | default('not set') | lower }}"
      when: sshd_config is defined and audit_results.ssh is defined

    - name: Record SSH Configuration Results
      set_fact:
        audit_results: "{{ audit_results | combine({'ssh': ssh_ssh_updated}) }}"
      vars:
        ssh_config_results:
          config_PermitRootLogin:
            status: "{{ 'PASS' if ssh_config.PermitRootLogin == 'no' else 'FAIL' }}"
            message: "{{ 'PermitRootLogin is set to no.' if ssh_config.PermitRootLogin == 'no' else 'PermitRootLogin is set to ' + ssh_config.PermitRootLogin }}"
          config_KbdInteractiveAuthentication:
            status: "{{ 'PASS' if ssh_config.KbdInteractiveAuthentication == 'no' else 'FAIL' }}"
            message: "{{ 'KbdInteractiveAuthentication is set to no.' if ssh_config.KbdInteractiveAuthentication == 'no' else 'KbdInteractiveAuthentication is set to ' + ssh_config.KbdInteractiveAuthentication }}"
          config_PasswordAuthentication:
            status: "{{ 'PASS' if ssh_config.PasswordAuthentication == 'no' else 'FAIL' }}"
            message: "{{ 'PasswordAuthentication is set to no.' if ssh_config.PasswordAuthentication == 'no' else 'PasswordAuthentication is set to ' + ssh_config.PasswordAuthentication }}"
          config_UsePAM:
            status: "{{ 'PASS' if ssh_config.UsePAM == 'no' else 'FAIL' }}"
            message: "{{ 'UsePAM is set to no.' if ssh_config.UsePAM == 'no' else 'UsePAM is set to ' + ssh_config.UsePAM }}"
        ssh_ssh_updated: "{{ audit_results.ssh | combine(ssh_config_results) }}"
      when: ssh_config is defined and audit_results.ssh is defined

    - name: Check Non-Root Sudo Users
      shell: |
        grep -Po '^sudo:.*:\K.*$' /etc/group | tr ',' '\n' | grep -v '^root$'
      register: sudo_users

    - name: Check Admin Group Users
      shell: |
        grep -Po '^admin:.*:\K.*$' /etc/group | tr ',' '\n' | grep -v '^root$'
      register: admin_users

    - name: Combine Sudo and Admin Users
      set_fact:
        privileged_users: "{{ (sudo_users.stdout_lines + admin_users.stdout_lines) | unique | reject('equalto', '') | list }}"

    - name: Check Valid Shells for Sudo Users
      shell: |
        for user in {{ privileged_users | join(' ') }}; do
          getent passwd "$user" | cut -d: -f7
        done
      register: user_shells
      when: privileged_users | length > 0

    - name: Record Non-Root Sudo Users Result
      set_fact:
        audit_results: "{{ audit_results | combine({'non_root_user': non_root_user_results}) }}"
      vars:
        non_root_user_results:
          sudo_access:
            status: "{{ 'PASS' if (user_shells.stdout_lines | select('match', '^(?!/usr/sbin/nologin$)(?!/bin/false$).+') | list | length) > 0 else 'FAIL' }}"
            message: "{{ 'Found valid non-root sudo users.' if (user_shells.stdout_lines | select('match', '^(?!/usr/sbin/nologin$)(?!/bin/false$).+') | list | length) > 0 else 'No non-root users with sudo privileges have valid shells.' }}"
      when: user_shells is defined

    - name: Check Unattended Upgrades Installation
      apt:
        name: unattended-upgrades
        state: present
      check_mode: yes
      register: unattended_upgrades_installed
      ignore_errors: yes

    - name: Record Unattended Upgrades Installation Result
      set_fact:
        audit_results: "{{ audit_results | combine({'unattended_upgrades': unattended_upgrades}) }}"
      vars:
        unattended_upgrades:
          installation:
            status: "{{ 'PASS' if unattended_upgrades_installed.changed == False else 'FAIL' }}"
            message: "{{ 'unattended-upgrades package is installed.' if unattended_upgrades_installed.changed == False else 'unattended-upgrades package is not installed.' }}"
      when: unattended_upgrades_installed is defined

    - name: Gather Service Facts for Unattended Upgrades
      service_facts:
      when: audit_results.unattended_upgrades.installation.status == 'PASS'

    - name: Record Unattended Upgrades Service Status
      set_fact:
        audit_results: "{{ audit_results | combine({'unattended_upgrades': unattended_upgrades_service}) }}"
      vars:
        unattended_upgrades_service:
          service_status:
            status: "{{ 'PASS' if (ansible_facts.services['unattended-upgrades.service'].state == 'running') else 'FAIL' }}"
            message: "{{ 'unattended-upgrades service is running.' if (ansible_facts.services['unattended-upgrades.service'].state == 'running') else 'unattended-upgrades service is not running.' }}"
      when:
        - "'unattended-upgrades.service' in ansible_facts.services"
        - audit_results.unattended_upgrades.installation.status == 'PASS'

    - name: Check Automatic Upgrades Configuration File
      stat:
        path: /etc/apt/apt.conf.d/20auto-upgrades
      register: auto_upgrades_file

    - name: Record Automatic Upgrades Configuration File Result
      set_fact:
        audit_results: "{{ audit_results | combine({'unattended_upgrades': unattended_upgrades_config}) }}"
      vars:
        unattended_upgrades_config:
          config_file:
            status: "{{ 'PASS' if auto_upgrades_file.stat.exists else 'FAIL' }}"
            message: "{{ 'Auto-upgrades configuration file exists.' if auto_upgrades_file.stat.exists else 'Auto-upgrades configuration file does not exist.' }}"
      when: auto_upgrades_file is defined

    - name: Check Automatic Update Settings
      shell: |
        if [ -f /etc/apt/apt.conf.d/20auto-upgrades ]; then
          grep -E "APT::Periodic::(Update-Package-Lists|Unattended-Upgrade)" /etc/apt/apt.conf.d/20auto-upgrades | awk '{print $3}'
        else
          echo "0 0"
        fi
      register: auto_update_settings
      when: audit_results.unattended_upgrades.config_file.status == 'PASS'
      ignore_errors: yes

    - name: Record Automatic Update Settings Result
      set_fact:
        audit_results: "{{ audit_results | combine({'unattended_upgrades': unattended_upgrades_auto}) }}"
      vars:
        unattended_upgrades_auto:
          auto_update:
            status: "{{ 'PASS' if (auto_update_settings.stdout.split()[0] | int) > 0 else 'FAIL' }}"
            message: "{{ 'Automatic package list updates are enabled.' if (auto_update_settings.stdout.split()[0] | int) > 0 else 'Automatic package list updates are disabled.' }}"
          auto_upgrade:
            status: "{{ 'PASS' if (auto_update_settings.stdout.split()[1] | int) > 0 else 'FAIL' }}"
            message: "{{ 'Automatic upgrades are enabled.' if (auto_update_settings.stdout.split()[1] | int) > 0 else 'Automatic upgrades are disabled.' }}"
      when: auto_update_settings is defined and audit_results.unattended_upgrades.config_file.status == 'PASS'

    - name: Check Fail2ban Installation
      apt:
        name: fail2ban
        state: present
      check_mode: yes
      register: fail2ban_installed
      ignore_errors: yes

    - name: Record Fail2ban Installation Result
      set_fact:
        audit_results: "{{ audit_results | combine({'fail2ban': fail2ban}) }}"
      vars:
        fail2ban:
          installation:
            status: "{{ 'PASS' if fail2ban_installed.changed == False else 'FAIL' }}"
            message: "{{ 'fail2ban package is installed.' if fail2ban_installed.changed == False else 'fail2ban package is not installed.' }}"
      when: fail2ban_installed is defined

    - name: Gather Service Facts for Fail2ban
      service_facts:
      when: audit_results.fail2ban.installation.status == 'PASS'

    - name: Record Fail2ban Service Status
      set_fact:
        audit_results: "{{ audit_results | combine({'fail2ban': fail2ban_service}) }}"
      vars:
        fail2ban_service:
          service_enabled:
            status: "{{ 'PASS' if (ansible_facts.services['fail2ban.service'].state == 'running' and ansible_facts.services['fail2ban.service'].enabled) else 'FAIL' }}"
            message: "{{ 'fail2ban service is enabled and running.' if (ansible_facts.services['fail2ban.service'].state == 'running' and ansible_facts.services['fail2ban.service'].enabled) else 'fail2ban service is not enabled or not running.' }}"
      when:
        - "'fail2ban.service' in ansible_facts.services"
        - audit_results.fail2ban.installation.status == 'PASS'

    - name: Check Fail2ban Configuration File
      stat:
        path: /etc/fail2ban/jail.local
      register: jail_local_file
      when: audit_results.fail2ban.installation.status == 'PASS'

    - name: Record Fail2ban Configuration File Result
      set_fact:
        audit_results: "{{ audit_results | combine({'fail2ban': fail2ban_config}) }}"
      vars:
        fail2ban_config:
          config_file:
            status: "{{ 'PASS' if jail_local_file.stat.exists else 'FAIL' }}"
            message: "{{ 'jail.local configuration file exists.' if jail_local_file.stat.exists else 'jail.local configuration file does not exist.' }}"
      when: jail_local_file is defined and audit_results.fail2ban is defined

    - name: Check SSH Jail Enabled in Fail2ban
      shell: |
        grep -E "^\[sshd\]" -A5 /etc/fail2ban/jail.local | grep "^enabled = true"
      register: ssh_jail_enabled
      when:
        - jail_local_file.stat.exists
        - audit_results.fail2ban.installation.status == 'PASS'
      ignore_errors: yes

    - name: Record SSH Jail Enabled Result
      set_fact:
        audit_results: "{{ audit_results | combine({'fail2ban': fail2ban_ssh_jail_enabled}) }}"
      vars:
        fail2ban_ssh_jail_enabled:
          ssh_jail_enabled:
            status: "{{ 'PASS' if ssh_jail_enabled.rc == 0 else 'FAIL' }}"
            message: "{{ 'SSH jail is enabled in fail2ban.' if ssh_jail_enabled.rc == 0 else 'SSH jail is not enabled in fail2ban.' }}"
      when: ssh_jail_enabled is defined and audit_results.fail2ban is defined

    - name: Check SSH Jail Mode in Fail2ban
      shell: |
        grep -E "^\[sshd\]" -A10 /etc/fail2ban/jail.local | grep "^mode\s*=\s*aggressive"
      register: ssh_jail_mode
      when:
        - jail_local_file.stat.exists
        - audit_results.fail2ban.installation.status == 'PASS'
      ignore_errors: yes

    - name: Record SSH Jail Mode Result
      set_fact:
        audit_results: "{{ audit_results | combine({'fail2ban': fail2ban_ssh_jail_mode}) }}"
      vars:
        fail2ban_ssh_jail_mode:
          ssh_jail_mode:
            status: "{{ 'PASS' if ssh_jail_mode.rc == 0 else 'FAIL' }}"
            message: "{{ 'SSH jail is set to aggressive mode.' if ssh_jail_mode.rc == 0 else 'SSH jail is not set to aggressive mode.' }}"
      when: ssh_jail_mode is defined and audit_results.fail2ban is defined

    - name: Create Jinja2 Template for Report
      copy:
        dest: "./security_audit_report.j2"
        content: |
          # Security Audit Report for {{ inventory_hostname }}

          ## 1. Operating System Check
          - **Status**: {{ audit_results.os_check.status }}
          - **Message**: {{ audit_results.os_check.message }}

          ## 2. Dependencies Check
          - **Status**: {{ audit_results.dependencies.status }}
          - **Message**: {{ audit_results.dependencies.message }}

          ## 3. UFW Security Check
          ### Installation
          - **Status**: {{ audit_results.ufw.installation.status }}
          - **Message**: {{ audit_results.ufw.installation.message }}

          ### Active Status
          - **Status**: {{ audit_results.ufw.active_status.status }}
          - **Message**: {{ audit_results.ufw.active_status.message }}

          ### Default Incoming Policy
          - **Status**: {{ audit_results.ufw.default_policy.status }}
          - **Message**: {{ audit_results.ufw.default_policy.message }}

          ## 4. SSH Security Check
          ### Service Status
          - **Status**: {{ audit_results.ssh.service_status.status }}
          - **Message**: {{ audit_results.ssh.service_status.message }}

          {% if audit_results.ssh.service_status.status == 'PASS' %}
          ### Key-based Authentication
          - **Status**: {{ audit_results.ssh.key_auth.status }}
          - **Message**: {{ audit_results.ssh.key_auth.message }}

          ### Configuration Settings
          - **PermitRootLogin**: {{ audit_results.ssh.config_PermitRootLogin.status }} - {{ audit_results.ssh.config_PermitRootLogin.message }}
          - **KbdInteractiveAuthentication**: {{ audit_results.ssh.config_KbdInteractiveAuthentication.status }} - {{ audit_results.ssh.config_KbdInteractiveAuthentication.message }}
          - **PasswordAuthentication**: {{ audit_results.ssh.config_PasswordAuthentication.status }} - {{ audit_results.ssh.config_PasswordAuthentication.message }}
          - **UsePAM**: {{ audit_results.ssh.config_UsePAM.status }} - {{ audit_results.ssh.config_UsePAM.message }}
          {% endif %}

          ## 5. Non-Root User Check
          - **Status**: {{ audit_results.non_root_user.sudo_access.status }}
          - **Message**: {{ audit_results.non_root_user.sudo_access.message }}

          ## 6. Unattended Upgrades Check
          ### Installation
          - **Status**: {{ audit_results.unattended_upgrades.installation.status }}
          - **Message**: {{ audit_results.unattended_upgrades.installation.message }}

          {% if audit_results.unattended_upgrades.installation.status == 'PASS' %}
          ### Service Status
          - **Status**: {{ audit_results.unattended_upgrades.service_status.status }}
          - **Message**: {{ audit_results.unattended_upgrades.service_status.message }}

          ### Automatic Update Settings
          - **Automatic Package List Updates**: {{ audit_results.unattended_upgrades.auto_update.status }} - {{ audit_results.unattended_upgrades.auto_update.message }}
          - **Automatic Upgrades**: {{ audit_results.unattended_upgrades.auto_upgrade.status }} - {{ audit_results.unattended_upgrades.auto_upgrade.message }}
          {% endif %}

          ## 7. Fail2ban Check
          ### Installation
          - **Status**: {{ audit_results.fail2ban.installation.status }}
          - **Message**: {{ audit_results.fail2ban.installation.message }}

          {% if audit_results.fail2ban.installation.status == 'PASS' %}
          ### Service Status
          - **Status**: {{ audit_results.fail2ban.service_enabled.status }}
          - **Message**: {{ audit_results.fail2ban.service_enabled.message }}

          ### Configuration File
          - **Status**: {{ audit_results.fail2ban.config_file.status }}
          - **Message**: {{ audit_results.fail2ban.config_file.message }}

          {% if audit_results.fail2ban.config_file.status == 'PASS' %}
          ### SSH Jail Configuration
          - **SSH Jail Enabled**: {{ audit_results.fail2ban.ssh_jail_enabled.status }} - {{ audit_results.fail2ban.ssh_jail_enabled.message }}
          - **SSH Jail Mode**: {{ audit_results.fail2ban.ssh_jail_mode.status }} - {{ audit_results.fail2ban.ssh_jail_mode.message }}
          {% endif %}
          {% endif %}

          ---
          *Report generated on {{ ansible_date_time.date }} at {{ ansible_date_time.time }}.*

    - name: Generate Markdown Report After Template Creation
      template:
        src: "./security_audit_report.j2"
        dest: "{{ report_path }}"
      vars:
        audit_results: "{{ audit_results }}"
      when:
        - inventory_hostname is defined

    - name: Display Report Path
      debug:
        msg: "Security audit report generated at {{ report_path }}"
