#!/usr/bin/env -S uv run
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "requests",
# ]
# ///

import requests
import shutil
import os
import datetime
from pathlib import Path

# --- CONFIGURATION ---
QDRANT_HOST = "http://10.0.0.20:6333"
BACKUP_ROOT = Path("/mnt/backup-qdrant/snapshots")
# ---------------------

def get_collections():
    try:
        r = requests.get(f"{QDRANT_HOST}/collections")
        r.raise_for_status()
        return [c['name'] for c in r.json()['result']['collections']]
    except Exception as e:
        print(f"Failed to fetch collections: {e}")
        return []

def create_snapshot(collection_name):
    print(f"[{collection_name}] Triggering snapshot...")
    try:
        # wait=true ensures the file is fully written on disk before we move it
        r = requests.post(f"{QDRANT_HOST}/collections/{collection_name}/snapshots?wait=true")
        r.raise_for_status()
        return r.json()['result']['name'] # Returns the raw filename generated by Qdrant
    except Exception as e:
        print(f"[{collection_name}] Snapshot failed: {e}")
        return None

def rotate_and_clean(collection_name, raw_filename):
    """
    Moves the raw snapshot to our organized folder and applies retention logic:
    - Always save as HOURLY
    - If midnight -> Save copy as DAILY
    - If Sunday midnight -> Save copy as WEEKLY
    """
    
    # The folder inside the docker volume (mapped to host)
    col_backup_dir = BACKUP_ROOT / collection_name
    col_backup_dir.mkdir(parents=True, exist_ok=True)
    
    source_file = col_backup_dir / raw_filename
    
    if not source_file.exists():
        print(f"[{collection_name}] Error: Source file {source_file} not found!")
        return

    now = datetime.datetime.now()
    timestamp = now.strftime("%Y%m%d_%H%M%S")
    
    # 1. Define Destinations
    hourly_name = f"hourly_{timestamp}.snapshot"
    daily_name = f"daily_{timestamp}.snapshot"
    weekly_name = f"weekly_{timestamp}.snapshot"
    
    # 2. Always create Hourly
    dest_hourly = col_backup_dir / hourly_name
    if source_file.is_dir():
        shutil.copytree(source_file, dest_hourly)
    else:
        shutil.copy2(source_file, dest_hourly)
    print(f"[{collection_name}] Created {hourly_name}")

    # 3. Create Daily (At 00:00)
    if now.hour == 0:
        dest_daily = col_backup_dir / daily_name
        if source_file.is_dir():
            shutil.copytree(source_file, dest_daily)
        else:
            shutil.copy2(source_file, dest_daily)
        print(f"[{collection_name}] Created {daily_name}")

        # 4. Create Weekly (Sunday at 00:00)
        if now.weekday() == 6: # Sunday is 6
            dest_weekly = col_backup_dir / weekly_name
            if source_file.is_dir():
                shutil.copytree(source_file, dest_weekly)
            else:
                shutil.copy2(source_file, dest_weekly)
            print(f"[{collection_name}] Created {weekly_name}")

    # 5. Delete the raw file from Qdrant (we have our copies now)
    if source_file.is_dir():
        shutil.rmtree(source_file)
    else:
        source_file.unlink()

    # 6. Cleanup / Retention
    cleanup_files(col_backup_dir, "hourly_", hours=3)
    cleanup_files(col_backup_dir, "daily_", days=3)
    cleanup_files(col_backup_dir, "weekly_", days=21)

def cleanup_files(directory, prefix, hours=0, days=0):
    """Deletes files starting with prefix that are older than X hours/days"""
    limit_seconds = (days * 86400) + (hours * 3600)
    now_epoch = datetime.datetime.now().timestamp()

    for f in directory.glob(f"{prefix}*"):
        path_age = now_epoch - f.stat().st_mtime
        if path_age > limit_seconds:
            if f.is_file():
                print(f"Cleaning up old backup: {f.name}")
                f.unlink()
            else:
                print(f"Cleaning up old backup directory: {f.name}")
                shutil.rmtree(f)

if __name__ == "__main__":
    collections = get_collections()
    for col in collections:
        raw_name = create_snapshot(col)
        if raw_name:
            rotate_and_clean(col, raw_name)